lab1:  
  1. Practice documenting program logic in pseudo code
  2. Create an abstract data type for processing complex numbers.
  3. Become proficient in using Java's StringTokenizer class and the Java class library.

lab2:
  1. Modify and test Keyboard.java so it can be easily extended.
  2. Create a sub-class called Textread that extends Keyboard.java and allows access to multiple files.
  3. Understand enough of the original Keyboard.java program to answer the synthesis questions that follow.
  4. Practice accessing binary and text files.
  5. Practice accessing sequential and random files.

lab3:
  1. Be able to work with individual bits in java.
  2. Understand the serializable interface.
  3. Understand the comparable interface.
  4. Answer questions about a general-purpose class to be developed.
  5. Understand the use of a driver program for ‘glass box’ debugging.
  6. Develop a program that can grade true/false tests.


lab4:
  1. To become comfortable with recursion.
  2. To become comfortable with the Applets and the Graphics class.
  3. To understand how to position to pixels on the display.
  4. To understand how complex graphics can be created using fractals.
  5. Implement a graphics program using recursion and fractals.
  6. Answer questions about graphics, recursion, and fractals.

lab5:
  1. Be able to create a program using a GUI interface.
  2. Understand how to use Swing components and panels.
  3. Understand the Computer Science concept of a tree.
  4. Answer questions about the Java GUI interface.
  5. Practice using Swing JTabbedPane and JTree components.

lab6:
  1. To become comfortable with the use of Stacks.
  2. Implement a calculator program that makes use of Stacks.
  3. Answer questions about the use of Stacks.

lab7:
  1. To become comfortable programming with dynamic memory.
  2. To be able to construct a tree in Java
  3. To be able to implement traversal methods.
  4. Answer questions about using dynamic storage and trees.

lab8:
  1. To be able to implement a Java program with multiple threads.
  2. To use the java monitor capability to coordinate thread activity.
  3. To illustrate a problem that can be modeled using a finite state graph.
  4. To implement multiple threads without deadlock.
  5. To implement the dining philosopher problem.
  6. Answer questions about threads and monitors.
